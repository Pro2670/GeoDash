<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Geo-Dash PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Teko', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAYS */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Let clicks pass through to game */
        }

        .menu-box {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00f0ff;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            pointer-events: auto;
            box-shadow: 0 0 20px #00f0ff;
        }

        h1 { color: #fff; font-size: 60px; margin: 0; text-shadow: 4px 4px #000; -webkit-text-stroke: 1px #00f0ff; }
        p { color: #ccc; font-size: 24px; }
        
        button {
            background: #00f0ff;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            font-family: 'Teko', sans-serif;
            cursor: pointer;
            margin: 10px;
            transition: 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
        }
        button:hover { background: #fff; transform: scale(1.1); }

        .color-picker { display: flex; gap: 10px; justify-content: center; margin: 20px 0; }
        .swatch { width: 40px; height: 40px; border: 2px solid white; cursor: pointer; }
        
        #progress-bar {
            position: absolute;
            top: 0; left: 0; height: 10px; background: #00f0ff; width: 0%;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="progress-bar"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="main-menu" class="menu-box">
            <h1>GEO-DASH</h1>
            <p>Select Character Color</p>
            <div class="color-picker" id="color-selector">
                </div>
            <p>Select Level</p>
            <button onclick="startGame(0)">Level 1: Stereo</button>
            <button onclick="startGame(1)">Level 2: Madness</button>
        </div>

        <div id="death-screen" class="menu-box hidden">
            <h1 style="-webkit-text-stroke: 1px red; box-shadow: none; text-shadow: none; color: red;">CRASHED</h1>
            <p id="percent-text">0% Complete</p>
            <button onclick="resetLevel()">Retry</button>
            <button onclick="showMenu()">Menu</button>
        </div>
    </div>
</div>

<script>
    // --- ENGINE CONFIG ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Resize handling
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- AUDIO SYSTEM (Web Audio API for no-file sounds) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === 'jump') {
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'explode') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }
    }

    // --- GAME STATE ---
    let gameState = "MENU"; // MENU, PLAYING, DEAD, WIN
    let frame = 0;
    let cameraX = 0;
    
    // --- LEVEL DATA (The Map) ---
    // 0 = Empty, 1 = Block, 2 = Spike, 3 = Platform
    // Each row is a different height. Bottom is the floor.
    const levels = [
        // Level 1
        `
        ...........................................................................................
        ...........................................................................................
        ...........................................................................................
        .....................................1.....................................................
        ...................1.................1...1................111..............................
        .................111.......2.........1...1.......2........111......2..2....................
        ........2.......1111.......1.........1...1.......1........111......1..1....................
        1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        `,
        // Level 2 (Harder)
        `
        ...............................................................................................
        ...............................................................................................
        .................................1.............................................................
        ...............................111.............................................................
        ...................2.........11111.........2.......................2...........................
        ..................111.......111111.......111.......2.......2.......1...........................
        .......2.......2.11111.....1111111......11111......1.......1.......1........2...2...2..........
        11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        `
    ];

    let currentMap = [];
    const TILE_SIZE = 60; // Size of blocks

    // --- PLAYER OBJECT ---
    const player = {
        x: 0,
        y: 0,
        w: TILE_SIZE - 10, // Slightly smaller hitbox than tile
        h: TILE_SIZE - 10,
        dy: 0,
        dx: 9.5, // Horizontal Speed
        color: '#00f0ff',
        angle: 0,
        grounded: false,
        trail: []
    };

    const colors = ['#00f0ff', '#ff0055', '#ffff00', '#00ff00', '#aa00ff'];
    let particles = [];

    // --- INITIALIZATION ---
    function initColors() {
        const container = document.getElementById('color-selector');
        colors.forEach(c => {
            const d = document.createElement('div');
            d.className = 'swatch';
            d.style.backgroundColor = c;
            d.onclick = () => { player.color = c; d.style.borderColor = 'black'; };
            container.appendChild(d);
        });
    }
    initColors();

    function parseLevel(index) {
        currentMap = [];
        let rows = levels[index].trim().split('\n');
        // Clean whitespace
        rows = rows.map(r => r.trim());
        
        for(let r=0; r<rows.length; r++) {
            for(let c=0; c<rows[r].length; c++) {
                let char = rows[r][c];
                if(char !== '.') {
                    currentMap.push({
                        type: char, // '1' block, '2' spike
                        x: c * TILE_SIZE,
                        y: canvas.height - ((rows.length - r) * TILE_SIZE)
                    });
                }
            }
        }
        return rows[0].length * TILE_SIZE; // Total length
    }

    let levelLength = 0;

    function startGame(lvlIndex) {
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('death-screen').classList.add('hidden');
        
        levelLength = parseLevel(lvlIndex);
        
        // Reset Player
        player.x = 200;
        player.y = canvas.height - 300;
        player.dy = 0;
        player.angle = 0;
        player.grounded = false;
        player.trail = [];
        cameraX = 0;
        particles = [];
        
        gameState = "PLAYING";
        gameLoop();
    }

    // --- PHYSICS & LOGIC ---
    function update() {
        if(gameState !== "PLAYING") return;

        // Move Player
        player.x += player.dx;
        
        // Camera Follow
        cameraX = player.x - 300; // Keep player at 300px from left

        // Gravity
        player.dy += 1.8; // Heavy gravity like GD
        player.y += player.dy;

        // Rotation logic
        if (!player.grounded) {
            player.angle += 6; // Spin fast in air
        } else {
            // Snap to nearest 90
            let target = Math.round(player.angle / 90) * 90;
            player.angle += (target - player.angle) * 0.2;
        }

        // Add Trail
        if(frame % 3 === 0) {
            player.trail.push({x: player.x, y: player.y, angle: player.angle, a: 1.0});
        }
        // Fade Trail
        player.trail.forEach(t => t.a -= 0.05);
        player.trail = player.trail.filter(t => t.a > 0);

        checkCollisions();

        // Update Progress UI
        let percent = Math.min(100, Math.floor((player.x / levelLength) * 100));
        document.getElementById('progress-bar').style.width = percent + "%";

        // Check Win
        if(player.x > levelLength) {
            alert("Level Complete!");
            showMenu();
        }
    }

    function checkCollisions() {
        player.grounded = false;
        
        // Define Player Hitbox (smaller for fairness)
        let phb = {
            x: player.x + 10,
            y: player.y + 10,
            w: player.w - 20,
            h: player.h - 20
        };

        // Floor (Fail safe)
        if(player.y > canvas.height) killPlayer();

        // Object Collision
        for(let obj of currentMap) {
            // Optimization: Only check objects on screen
            if(obj.x < cameraX - 100 || obj.x > cameraX + canvas.width) continue;

            // AABB Collision
            if (phb.x < obj.x + TILE_SIZE &&
                phb.x + phb.w > obj.x &&
                phb.y < obj.y + TILE_SIZE &&
                phb.y + phb.h > obj.y) {
                
                if (obj.type === '2') {
                    // Spike = Instant Death
                    killPlayer();
                } else if (obj.type === '1') {
                    // Block Logic
                    resolveBlockCollision(phb, obj);
                }
            }
        }
    }

    function resolveBlockCollision(p, b) {
        // Calculate overlap
        let dx = (player.x + player.w/2) - (b.x + TILE_SIZE/2);
        let dy = (player.y + player.h/2) - (b.y + TILE_SIZE/2);
        let width = (player.w + TILE_SIZE) / 2;
        let height = (player.h + TILE_SIZE) / 2;
        let crossWidth = width * dy;
        let crossHeight = height * dx;

        if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
            if (crossWidth > crossHeight) {
                if (crossWidth > -crossHeight) {
                    // Collision from TOP (Landed on block)
                    if(player.dy > 0) {
                        player.y = b.y - player.h;
                        player.dy = 0;
                        player.grounded = true;
                    }
                } else {
                    // Collision from LEFT (Crashed into wall)
                    killPlayer();
                }
            } else {
                 // Bottom or Right (usually death or head bump)
                 if (crossWidth > -crossHeight) {
                     // Right
                     killPlayer();
                 } else {
                     // Bottom (Head hit)
                     player.y = b.y + TILE_SIZE;
                     player.dy = 0;
                 }
            }
        }
    }

    function killPlayer() {
        if(gameState === "DEAD") return;
        gameState = "DEAD";
        playSound('explode');
        
        // Create Explosion
        for(let i=0; i<30; i++) {
            particles.push({
                x: player.x + player.w/2,
                y: player.y + player.h/2,
                dx: (Math.random() - 0.5) * 15,
                dy: (Math.random() - 0.5) * 15,
                life: 1.0,
                color: player.color
            });
        }

        setTimeout(() => {
            let percent = Math.floor((player.x / levelLength) * 100);
            document.getElementById('percent-text').innerText = percent + "% Complete";
            document.getElementById('death-screen').classList.remove('hidden');
        }, 1000);
    }

    function jump() {
        if(gameState === "PLAYING" && player.grounded) {
            player.dy = -21; // Jump Force
            player.grounded = false;
            playSound('jump');
        }
    }

    // --- RENDER ---
    function draw() {
        ctx.fillStyle = "#1a1a2e"; // Background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Parallax Grid Effect
        ctx.strokeStyle = "rgba(0, 240, 255, 0.1)";
        ctx.lineWidth = 2;
        let gridOffset = -(cameraX * 0.5) % 100;
        for(let i=gridOffset; i<canvas.width; i+=100) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
        }

        // Apply Camera Transform
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw Map
        // Optimized: visible range only
        let startCol = Math.floor(cameraX / TILE_SIZE);
        let endCol = startCol + (canvas.width / TILE_SIZE) + 2;
        
        for(let obj of currentMap) {
            // Simple visibility check
            if(obj.x < cameraX - 100 || obj.x > cameraX + canvas.width + 100) continue;

            if (obj.type === '1') {
                // Block
                ctx.fillStyle = "#0f3460";
                ctx.fillRect(obj.x, obj.y, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = "#00f0ff";
                ctx.lineWidth = 2;
                ctx.strokeRect(obj.x, obj.y, TILE_SIZE, TILE_SIZE);
                // Inner Detail
                ctx.fillStyle = "rgba(0, 240, 255, 0.2)";
                ctx.fillRect(obj.x+10, obj.y+10, TILE_SIZE-20, TILE_SIZE-20);
            } else if (obj.type === '2') {
                // Spike
                ctx.fillStyle = "#ff0044";
                ctx.beginPath();
                ctx.moveTo(obj.x, obj.y + TILE_SIZE);
                ctx.lineTo(obj.x + TILE_SIZE/2, obj.y);
                ctx.lineTo(obj.x + TILE_SIZE, obj.y + TILE_SIZE);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.stroke();
            }
        }

        // Draw Player Trail
        player.trail.forEach(t => {
            ctx.save();
            ctx.translate(t.x + player.w/2, t.y + player.h/2);
            ctx.rotate(t.angle * Math.PI / 180);
            ctx.fillStyle = player.color;
            ctx.globalAlpha = t.a * 0.5;
            ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
            ctx.restore();
        });

        // Draw Player
        if(gameState === "PLAYING") {
            ctx.save();
            ctx.translate(player.x + player.w/2, player.y + player.h/2);
            ctx.rotate(player.angle * Math.PI / 180);
            
            // Icon Body
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
            
            // Icon Face (simple)
            ctx.fillStyle = "black";
            ctx.fillRect(-5, -5, 15, 15); // Eye
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;
            ctx.strokeRect(-player.w/2, -player.h/2, player.w, player.h);
            
            ctx.restore();
        }

        // Draw Particles (Explosion)
        particles.forEach((p, i) => {
            p.x += p.dx;
            p.y += p.dy;
            p.life -= 0.02;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, 10, 10);
            if(p.life <= 0) particles.splice(i, 1);
        });

        ctx.restore();
    }

    function gameLoop() {
        if(gameState === "MENU") return;
        frame++;
        update();
        draw();
        if(gameState !== "MENU") requestAnimationFrame(gameLoop);
    }

    // --- CONTROLS ---
    window.addEventListener('keydown', e => {
        if(e.code === 'Space' || e.code === 'ArrowUp') jump();
    });
    window.addEventListener('mousedown', jump);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});

    // --- UI FUNCTIONS ---
    function resetLevel() {
        // Find current level index based on levelLength (hacky but works for demo)
        // Ideally store currentLevelIndex
        let index = levelLength > 2000 ? 0 : 1; 
        startGame(index); 
    }

    function showMenu() {
        gameState = "MENU";
        document.getElementById('main-menu').classList.remove('hidden');
        document.getElementById('death-screen').classList.add('hidden');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

</script>
</body>
</html>
